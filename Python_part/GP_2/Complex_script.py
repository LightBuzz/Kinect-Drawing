# -*- coding: utf-8 -*-
"""shapeDetection_usingCoordinates.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1vSZNBh1UQxlfz13aA1JPf0_SrPlA0L8J

#Import
"""
import math
import random
import numpy as np
from numpy import asarray
import cv2
from PIL import Image, ImageDraw
import sys
from skimage.feature import hog
from sklearn import svm
from sklearn.metrics import classification_report,accuracy_score
import pickle
import sys
import os
import pathlib

"""#Obtain the path using OS argv"""

folder_path =  str(pathlib.Path().absolute()) + "\\models"
#folder_path = "C:\\Users\\khale\\source\\repos\\Kinect-Drawing\\Python_part\\GP_2"

#Obtain the path of the text file using OS argv
data_path = sys.argv[1]

"""#Preprocessing and obtain the data coord of many shapes from the txt file

"""
x_list = []
y_list = []
file_1 = open(data_path)
Data= file_1.readlines()
Coordinates=list()
count=0
Shapes=dict()
data_list_coordinates = []
for i in range(len(Data)):
    if "End" in Data[i]:
      Shapes[i]=Data[i-1]
for i in range(len(Data)):
    if "End" in Data[i]:
      Coordinates.append(Data[i-1])
for j in range(len(Coordinates)):
  data_list = Coordinates[j].split(" ")
  data_list_coordinates.append("Shape")
  for item in data_list:
    (x, y) = item.split(",")
    (x, y) = math.ceil(float(x)), math.ceil(float(y))
    data_list_coordinates.append((x, y))
    x_list.append(x)
    y_list.append(y)

len(Coordinates)




"""# Construct binary image using coords"""

my_screen_width = 1920
my_screen_height = 1080
length=len(data_list_coordinates)
K="Shape"
res1=[]
res2=[]
number_of_shapes=[data_list_coordinates.index(i,1) for i in data_list_coordinates[1:] if i == K]
number_of_shapes.insert(0,1)
res1=[i for i,x in enumerate(data_list_coordinates) if x==K]
res2=[i for i in range(len(data_list_coordinates)) if data_list_coordinates[i]==K]
#number_of_shapes.insert(len(number_of_shapes),length)
# let's create a 6 x 6 matrix with all pixels in black color
img = np.ones((my_screen_width, my_screen_height), np.uint8) * 255
data_list_coordinates1=[i for i in data_list_coordinates if i != K]
for data in data_list_coordinates1:
    img[data[0], data[1]] = 0

cv2.imwrite("t1.png", img)

res1

"""# Mirroring"""

# load the image, create the mirrored image, and the result placeholder
img = Image.open("t1.png")
mirror = img.transpose(Image.FLIP_LEFT_RIGHT).transpose(Image.ROTATE_90)
mirror.save("t1.png")

"""# Connect points using a thick line"""

# from google.colab.patches import cv2_imshow
img = cv2.imread("t1.png")
for z in range(len(res1)):
  (pre_x, pre_y) = data_list_coordinates[res1[z]+1]
  if z != (len(res1)-1):
    for (x, y) in data_list_coordinates[res1[z]+1:res1[z+1]]:
      img = cv2.line(img, (pre_x, pre_y), (x, y), (0, 0, 0), 4)
      (pre_x, pre_y) = (x, y)
  else:
    for (x, y) in data_list_coordinates[res1[z]+1:]:
      img = cv2.line(img, (pre_x, pre_y), (x, y), (0, 0, 0), 4)
      (pre_x, pre_y) = (x, y)
# save our image as a "png" image
# cv2_imshow(img)
cv2.imwrite("t2.png", img)

# Cropping
x_min = min(x_list)
x_max = max(x_list)

y_min = min(y_list)
y_max = max(y_list)

w = x_max - x_min
h = y_max - y_min

img_orig = cv2.imread('t2.png', 0)

img_crop = img_orig[y_min:y_min + h, x_min:x_min + w]
cv2.imwrite('t2_cropped.png', img_crop)
# -------------------------------------------------------
#print("666")
# Padding

# read image
img = cv2.imread('t2_cropped.png')
ht, wd, cc = img.shape
ww = hh = (math.ceil(max(wd, ht) / 28) + 1) * 28

# create new image of desired size and color (blue) for padding
color = (255, 255, 255)
result = np.full((hh, ww, cc), color, dtype=np.uint8)

# compute center offset
xx = (ww - wd) // 2
yy = (hh - ht) // 2

# copy img image into center of result image
result[yy:yy + ht, xx:xx + wd] = img

# view result
# cv2_imshow(result)
# save result
cv2.imwrite("padded_cropped_img.png", result)
# -------------------------------------------------------
#print("777")
# resizing PIL   ->perfect
# image = Image.open('padded_cropped_img.png')
# new_image = image.resize((28, 28))
# new_image.save('padded_cropped_shrinked_img.png')
# final_img_path = 'padded_cropped_shrinked_img.png'
# # -------------------------------------------------------
final_img_path = "padded_cropped_img.png"
# # Preprocessing

# final_img_path = 'padded_cropped_shrinked_img.png'
# from keras.preprocessing import image
# img = image.load_img(final_img_path, color_mode="grayscale")
# x = image.img_to_array(img)
# x = np.expand_dims(x, axis=0)

# x = x.reshape(1, 784)
# x = x.astype('float32')
# # normalizing the data to help with the training
# x /= 255
 
# -------------------------------------------------------
# Prediction


def preprocess(img_path): #input an image   

    # load the image
    image = Image.open(img_path)
    # convert image to numpy array
    img_data = asarray(image)

    our_test = []
    our_test.append(img_data)


    our_test_resized = [cv2.resize(our_test[0], (320, 320))]

    ppc = 16
    hog_images = []
    hog_features = []
    for image in our_test_resized:
        fd,hog_image = hog(image, orientations=8, pixels_per_cell=(ppc,ppc),cells_per_block=(4, 4),block_norm= 'L2',visualize=True)
        hog_images.append(hog_image)
        hog_features.append(fd)

    hog_features = np.array(hog_features)
    return hog_features


#Test1
#folder_path  = "C:\\Users\\khale\\Source\\Repos\\Kinect-Drawing\\Python_part\\GP_2"
filename = os.path.join(folder_path, 'Complex_v4_finalized_model.pkl')
loaded_model = pickle.load(open(filename, 'rb'))


#print("888")
predicted_class = loaded_model.predict(preprocess(final_img_path))
prob_of_classes = loaded_model.predict_proba(preprocess(final_img_path))


#print("999")
predicted_class =  str(predicted_class)


prob_of_classes = prob_of_classes[0]
prob_of_classes_rounded = []
for class_i in prob_of_classes:
    prob_of_classes_rounded.append(int(round(class_i,2) * 100))

#mapping part 
if predicted_class[1] == '0' and prob_of_classes_rounded[0] >= 0:
    predicted_class = "Candle"
elif predicted_class[1] == '1' and prob_of_classes_rounded[1] >= 0:
    predicted_class = "Beer-Mug"
elif predicted_class[1] == '2' and prob_of_classes_rounded[2] >= 0:
    predicted_class = "TV"
elif predicted_class[1] == '3' and prob_of_classes_rounded[3] >= 0:
    predicted_class = "axe"
elif predicted_class[1] == '4' and prob_of_classes_rounded[4] >= 0:
    predicted_class = "House"
elif predicted_class[1] == '5' and prob_of_classes_rounded[5] >= 0:
    predicted_class = "bowl"
else:
    predicted_class = "I Don't know!"








print(predicted_class + " " +  str(prob_of_classes_rounded))
#print(predicted_class + " " +  str(max(prob_of_classes_rounded)))